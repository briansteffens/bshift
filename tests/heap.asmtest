import heap;

u64 test_allocate()
{
    u64* a = heap::allocate(8);

    *a = 137;

    return *a;
}

u64 test_separate_allocations()
{
    u64* a = heap::allocate(8);
    u64* b = heap::allocate(8);

    return a != b;
}

u64 test_allocate_large()
{
    u8* a = heap::allocate(8192);

    *a = 3;

    a = a + 8184;

    *a = 7;

    return *a;
}

u64 test_free_same_size()
{
    u64* a = heap::allocate(8);

    *a = 13;

    heap::free(a);

    u64* b = heap::allocate(8);

    return *b;
}

u64 test_free_previous()
{
    u64* a = heap::allocate(8);
    u64* b = heap::allocate(8);

    heap::free(a);
    heap::free(b);

    u64* c = heap::allocate(16);

    return a == c;
}

u64 test_free_next()
{
    u64* a = heap::allocate(8);
    u64* b = heap::allocate(8);

    heap::free(b);
    heap::free(a);

    u64* c = heap::allocate(16);

    return a == c;
}

u64 test_free_minimum_one_region()
{
    u64* a = heap::allocate(8);

    heap::free(a);

    return heap::__debug_region_count() == 1;
}

u64 test_free_unmap()
{
    u64* a = heap::allocate(2048);
    u64* b = heap::allocate(2048);

    if (heap::__debug_region_count() != 2)
    {
        return 10;
    }

    heap::free(b);

    return heap::__debug_region_count() == 1;
}

u64 test_grow_super_region()
{
    u64 original_super_region_size = heap::__debug_super_region_size();
    u64 max = 300;

    while (max > 0)
    {
        heap::allocate(2048);

        if (heap::__debug_super_region_size() > original_super_region_size)
        {
            return 1;
        }

        max = max - 1;
    }

    return 0;
}

u64 main()
{
    return test_{{ test }}();
}

-----

{
    "cases": [
        {
            "name": "allocate memory, write to it, and read from it",
            "test": "allocate",
            "expect_status": "137"
        },
        {
            "name": "get different addresses for separate allocations",
            "test": "separate_allocations",
            "expect_status": "1"
        },
        {
            "name": "get the same address for same size allocation after free",
            "test": "free_same_size",
            "expect_status": "13"
        },
        {
            "name": "allocate more than the standard region size",
            "test": "allocate_large",
            "expect_status": "7"
        },
        {
            "name": "free absorbs previous adjacent free block",
            "test": "free_previous",
            "expect_status": "1"
        },
        {
            "name": "free absorbs next adjacent free block",
            "test": "free_next",
            "expect_status": "1"
        },
        {
            "name": "free always keeps at least one region mapped",
            "test": "free_minimum_one_region",
            "expect_status": "1"
        },
        {
            "name": "free unmaps regions that aren't needed anymore",
            "test": "free_unmap",
            "expect_status": "1"
        },
        {
            "name": "super region grows if enough regions are mapped",
            "test": "grow_super_region",
            "expect_status": "1"
        }
    ]
}
