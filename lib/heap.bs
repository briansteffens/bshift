import io;

u8* super_region = 0;
u64* region_count = 0;

u64 allocation_header_size = 9;
u64 region_min_size = 4096;

struct region
{
    u8* address;
    u64 size;
}

struct allocation
{
    bool free;
    u64 size;
}

region* get_region(u64 index)
{
    u8* address = super_region;
    address = address + 8;

    while (index > 0)
    {
        address = address + sizeof(region);
        index = index - 1;
    }

    return address;
}

u8* map(u64 len)
{
    return syscall(9, 0, len, 3, 33, 0, 0);
}

void init()
{
    super_region = map(4096);
    region_count = super_region;

    *region_count = 0;
}

allocation* next_allocation(region* reg, allocation* current)
{
    u64 end_of_region = reg.address + reg.size;

    u64* alloc_ptr = current;
    alloc_ptr = alloc_ptr + allocation_header_size + current.size;

    if (alloc_ptr >= end_of_region)
    {
        return 0;
    }

    return alloc_ptr;
}

allocation* find_free(u64 bytes)
{
    u64 region_index = 0;
    while (region_index < *region_count)
    {
        auto reg = get_region(region_index);
        allocation* alloc = reg.address;

        while (alloc != 0)
        {
            auto alloc_size = alloc.size;
            if (alloc.free == 1 && alloc_size >= bytes)
            {
                return alloc;
            }

            alloc = next_allocation(reg, alloc);
        }

        region_index = region_index + 1;
    }

    return 0;
}

region* allocate_region(u64 min_bytes)
{
    auto min_size = allocation_header_size + min_bytes;
    if (min_size < region_min_size)
    {
        min_size = region_min_size;
    }

    auto new_region = get_region(*region_count);
    *region_count = *region_count + 1;

    new_region.address = map(min_size);
    new_region.size = min_size;

    allocation* alloc = new_region.address;
    alloc.free = true;
    alloc.size = new_region.size - allocation_header_size;

    return new_region;
}

u8* allocate(u64 bytes)
{
    if (super_region == 0)
    {
        init();
    }

    auto alloc = find_free(bytes);

    if (alloc == 0)
    {
        auto reg = allocate_region(bytes);
        if (reg == 0)
        {
            return 0;
        }
        alloc = reg.address;
    }

    u8* alloc_ptr = alloc;
    auto remaining = alloc.size - bytes;

    if (remaining >= allocation_header_size)
    {
        alloc.size = bytes;

        allocation* next_alloc = alloc_ptr + allocation_header_size + bytes;
        next_alloc.free = true;
        next_alloc.size = remaining - allocation_header_size;
    }

    alloc.free = false;

    return alloc_ptr + allocation_header_size;
}

void free(u8* ptr)
{
    allocation* alloc = ptr - allocation_header_size;
    alloc.free = true;
}

// Prints debugging info listing all regions and allocations
void debug_info()
{
    u64 region_index = 0;
    while (region_index < *region_count)
    {
        auto reg = get_region(region_index);

        io::print("region %u\n", region_index);

        allocation* alloc = reg.address;

        while (alloc != 0)
        {
            if (alloc.free)
            {
                io::print("    free ");
            }
            else
            {
                io::print("    used ");
            }

            io::print("%u bytes\n", alloc.size);

            alloc = next_allocation(reg, alloc);
        }

        region_index = region_index + 1;
    }
}
